#pragma config(UART_Usage, UART2, uartNotUsed, baudRate4800, IOPins, None, None)
#pragma config(I2C_Usage, I2C1, i2cSensors)
#pragma config(Sensor, dgtl1,  red1,           sensorLEDtoVCC)
#pragma config(Sensor, dgtl2,  red2,           sensorLEDtoVCC)
#pragma config(Sensor, dgtl3,  green1,         sensorLEDtoVCC)
#pragma config(Sensor, dgtl4,  green2,         sensorLEDtoVCC)
#pragma config(Sensor, dgtl5,  button1,        sensorTouch)
#pragma config(Sensor, dgtl6,  button2,        sensorTouch)
#pragma config(Sensor, dgtl11, red3,           sensorLEDtoVCC)
#pragma config(Sensor, dgtl12, red4,           sensorLEDtoVCC)
#pragma config(Sensor, I2C_1,  ,               sensorQuadEncoderOnI2CPort,    , AutoAssign )
#pragma config(Sensor, I2C_2,  ,               sensorQuadEncoderOnI2CPort,    , AutoAssign )
#pragma config(Sensor, I2C_3,  ,               sensorQuadEncoderOnI2CPort,    , AutoAssign )
#pragma config(Motor,  port1,           baseRotation,  tmotorVex393_HBridge, openLoop)
#pragma config(Motor,  port2,           baseLift,      tmotorVex393_MC29, openLoop, encoderPort, I2C_1)
#pragma config(Motor,  port3,           elbowLift,     tmotorVex393_MC29, openLoop, encoderPort, I2C_2)
#pragma config(Motor,  port4,           handLift,      tmotorVex393_MC29, openLoop, encoderPort, I2C_3)
#pragma config(Motor,  port5,           handRotation,  tmotorVex393_MC29, openLoop)
#pragma config(Motor,  port6,           handClaw,      tmotorVex393_MC29, openLoop)
#pragma config(DatalogSeries, 0, "I2C Encoder 1 - Base Rotation", Sensors, Sensor, I2C_1, 10)
#pragma config(DatalogSeries, 1, "I2C Encoder 2 - Base Lift", Sensors, Sensor, I2C_2, 10)
#pragma config(DatalogSeries, 2, "I2C Encoder 3 - Elbow Lift", Sensors, Sensor, I2C_3, 10)
#pragma config(DatalogSeries, 3, "I2C Encoder 4 - Hand Lift", Sensors, Sensor, I2C_4, 10)
#pragma config(DatalogSeries, 4, "I2C Encoder 5 - Hand Rotation", Sensors, Sensor, I2C_5, 10)
#pragma config(DatalogSeries, 5, "I2C Encoder 6 - Claw", Sensors, Sensor, I2C_6, 10)
//*!!Code automatically generated by 'ROBOTC' configuration wizard               !!*//

/*



                      _____          ___         _____
                     |__  /         <  /        /__  /
                      /_ <          / /           / /  ______
                    ___/ /   _     / /   _       / /  /_____/
                   /____/   (_)   /_/   (_)     /_/

           _____                  _            __   ___
          / ___/__  ___________ _(_)________ _/ /  /   |  _________ ___
          \__ \/ / / / ___/ __ `/ / ___/ __ `/ /  / /| | / ___/ __ `__ \
         ___/ / /_/ / /  / /_/ / / /__/ /_/ / /  / ___ |/ /  / / / / / /
        /____/\__,_/_/   \__, /_/\___/\__,_/_/  /_/  |_/_/  /_/ /_/ /_/
                        /____/

                   /`   | _  |    |_|      . _   |).   _   ,_
                   \,()(|(/_ |)\/ | |(||`|`|(/_|`| |(|(/_()||
                               /                    _|

 */

// By the way, this is for a Vex Cortex with PLTW Natural Language Enabled and C functions enabled as well. 

/* in Visual Studio Code, commenting out a multiline block  is Shift+Alt+A. */
// In the RobotC IDE, the shortcut is Ctrl-Q.


//DECLARING "STATIC" VARIABLES FOR MATH STUFF

// Creating structures for organization, cleanliness, and anti-brain-crash measures.

/*
	+-+-+-+-+-+-+-+-+-+-+-+
	|c|a|l|i|b|r|a|t|i|o|n|
	+-+-+-+-+-+-+-+-+-+-+-+
*/

struct MotorCalibrationControlStructure {
	/* 	 these two are the limit switches that mark the end of the arm's rotation in that direction. */
	int lowerLimitPort;
	int upperLimitPort;		//This could technically be the same as the first one- would allow for full 360* rotation.
	float stepsPerDegree; 	//When calibrated, this will be how many degrees the encoder has to rotate in order to get to the next degree of movement.  Bypasses the need for a bunch of gear ratio junk.
	float lowerLimitDeg;	//Physical degrees from relative origin to where the lowerLimitSwitch is.
	float upperLimitDeg;	// ` ` to where the upperLimitSwitch is.
	float totalDeg;
	int lowerEncodeDeg;  	//Encoder counts from relative origin to bottom limit.
	int upperEncodeDeg;		//Encoder counts from relative origin to upper limit.
	int isCalibrated;
};

  // Calibration Function

float Calibrate(struct MotorControlStructure current) {  //returns steps per degree.
	current.calibration.isCalibrated = 0;
	while (current.calibration.isCalibrated == 0) {
		if (sensorValue[current.calibration.lowerLimitPort] == 0) {
			startMotor(current.motorPort, (current.maxPower/2)*current.reverse*-1);
		} else {
			current.calibration.lowerEncodeDeg = sensorValue[current.encoderPort];
			stopMotor(current.motorPort);
			startMotor(current.motorPort,(current.maxPower/2)*current.reverse);
			waitInMilliseconds(500);
      if(SensorValue[] current.calibration.upperLimitPort] == 0) {
      }
         

	}




	current.calibration.isCalibrated = 1;
	}


}





/*
	+-+-+-+-+-+ +-+-+-+-+-+-+-+ +-+-+-+-+-+-+-+-+-+
	|M|o|t|o|r| |C|o|n|t|r|o|l| |S|t|r|u|c|t|u|r|e|
	+-+-+-+-+-+ +-+-+-+-+-+-+-+ +-+-+-+-+-+-+-+-+-+
 */

struct MotorControlStructure 		// (StructureName)
{
	int motorPort;								// (StructureName).motorPort
	int encoderPort;							// (StructureName).encoderPort
	int gearRatio;								// (StructureName).gearRatio
	int encoderCalibrationValue;	// (StructureName).encoderCalibrationValue
	int maxPower;
	struct MotorCalibrationControlStructure calibration;
	int reverse;  // Either -1 or 1, depending on if the motor needs to go the other direction.
};


//This might have been outdated by my most current concept of the necessary code.  Wheeee.
struct ArmLengthMathSubStructure // (struct RobotArmControlStructure name).(struct ArmLengthMathSubStructure).XXX
{
	 float length;
	 float height;
	 float MA;
	 float angleA;
	 float lengthA;
	 float angleB;
	 float lengthB;
	 float angleC;
	 float lengthC;

};

struct RobotArmControlStructure
{
	struct MotorControlStructure shoulder;
	struct MotorControlStructure elbow;
	struct MotorControlStructure wrist;
	struct ArmLengthMathSubStructure lengthMath;

};





task main()
{

}
